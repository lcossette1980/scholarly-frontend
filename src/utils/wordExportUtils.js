import { 
  Document, 
  Packer, 
  Paragraph, 
  TextRun, 
  HeadingLevel, 
  AlignmentType, 
  PageBreak,
  Header,
  Footer,
  PageNumber,
  NumberFormat,
  BorderStyle,
  ShadingType,
  convertInchesToTwip,
  Tab,
  TabStopType,
  TabStopPosition
} from 'docx';
import { cleanMarkdownContent, parseMarkdownToDocxElements, extractFormattedText } from './markdownCleaner';
import { wordExportConfig } from '../config/wordExportConfig';

const STYLES = {
  fonts: wordExportConfig.typography.fonts,
  colors: wordExportConfig.colors,
  spacing: wordExportConfig.spacing,
  sizes: wordExportConfig.typography.sizes
};

const createDocumentHeader = () => {
  return new Header({
    children: [
      new Paragraph({
        children: [
          new TextRun({
            text: wordExportConfig.branding.companyName,
            font: STYLES.fonts.heading,
            size: STYLES.sizes.footer,
            color: STYLES.colors.secondary
          }),
          new TextRun({
            text: "\t\t",
          }),
          new TextRun({
            text: "Annotated Bibliography",
            font: STYLES.fonts.heading,
            size: STYLES.sizes.footer,
            color: STYLES.colors.secondary
          })
        ],
        tabStops: [
          {
            type: TabStopType.RIGHT,
            position: TabStopPosition.MAX
          }
        ],
        border: {
          bottom: {
            color: STYLES.colors.accent,
            space: 1,
            size: 6,
            style: BorderStyle.SINGLE
          }
        },
        spacing: {
          after: 120
        }
      })
    ]
  });
};

const createDocumentFooter = () => {
  return new Footer({
    children: [
      new Paragraph({
        children: [
          new TextRun({
            text: `Generated by ${wordExportConfig.branding.companyName}`,
            font: STYLES.fonts.body,
            size: STYLES.sizes.footer,
            color: STYLES.colors.secondary
          }),
          new TextRun({
            text: "\t\t",
          }),
          new TextRun({
            children: [PageNumber.CURRENT, " of ", PageNumber.TOTAL_PAGES],
            font: STYLES.fonts.body,
            size: STYLES.sizes.footer,
            color: STYLES.colors.secondary
          })
        ],
        alignment: AlignmentType.CENTER,
        tabStops: [
          {
            type: TabStopType.RIGHT,
            position: TabStopPosition.MAX
          }
        ],
        border: {
          top: {
            color: STYLES.colors.accent,
            space: 1,
            size: 6,
            style: BorderStyle.SINGLE
          }
        },
        spacing: {
          before: 120
        }
      })
    ]
  });
};

const createStyledParagraph = (text, options = {}) => {
  const { text: cleanText, formatting } = extractFormattedText(text);
  const children = [];
  let lastIndex = 0;
  
  formatting.sort((a, b) => a.start - b.start);
  
  formatting.forEach(({ type, start, end }) => {
    if (start > lastIndex) {
      children.push(
        new TextRun({
          text: cleanText.substring(lastIndex, start),
          font: options.font || STYLES.fonts.body,
          size: options.size || 24,
          color: options.color || '000000'
        })
      );
    }
    
    children.push(
      new TextRun({
        text: cleanText.substring(start, end),
        font: options.font || STYLES.fonts.body,
        size: options.size || 24,
        color: options.color || '000000',
        bold: type === 'bold' || options.bold,
        italics: type === 'italic' || options.italics
      })
    );
    
    lastIndex = end;
  });
  
  if (lastIndex < cleanText.length) {
    children.push(
      new TextRun({
        text: cleanText.substring(lastIndex),
        font: options.font || STYLES.fonts.body,
        size: options.size || 24,
        color: options.color || '000000',
        bold: options.bold,
        italics: options.italics
      })
    );
  }
  
  return new Paragraph({
    children: children.length > 0 ? children : [
      new TextRun({
        text: cleanText,
        font: options.font || STYLES.fonts.body,
        size: options.size || 24,
        color: options.color || '000000',
        bold: options.bold,
        italics: options.italics
      })
    ],
    alignment: options.alignment || AlignmentType.JUSTIFIED,
    spacing: {
      before: options.spacingBefore || 0,
      after: options.spacingAfter || STYLES.spacing.paragraph,
      line: STYLES.spacing.line
    },
    indent: options.indent,
    heading: options.heading
  });
};

const createTitlePage = (entries) => {
  return [
    new Paragraph({
      children: [
        new TextRun({
          text: "ANNOTATED BIBLIOGRAPHY",
          font: STYLES.fonts.heading,
          size: 56,
          color: STYLES.colors.primary,
          bold: true
        })
      ],
      alignment: AlignmentType.CENTER,
      spacing: {
        before: convertInchesToTwip(2),
        after: convertInchesToTwip(0.5)
      }
    }),
    new Paragraph({
      children: [
        new TextRun({
          text: "A Comprehensive Academic Reference Collection",
          font: STYLES.fonts.heading,
          size: 28,
          color: STYLES.colors.secondary,
          italics: true
        })
      ],
      alignment: AlignmentType.CENTER,
      spacing: {
        after: convertInchesToTwip(2)
      }
    }),
    new Paragraph({
      children: [
        new TextRun({
          text: `${entries.length} Annotated ${entries.length === 1 ? 'Entry' : 'Entries'}`,
          font: STYLES.fonts.body,
          size: 32,
          color: STYLES.colors.primary
        })
      ],
      alignment: AlignmentType.CENTER,
      spacing: {
        after: convertInchesToTwip(0.5)
      }
    }),
    new Paragraph({
      children: [
        new TextRun({
          text: new Date().toLocaleDateString('en-US', { 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric' 
          }),
          font: STYLES.fonts.body,
          size: 24,
          color: STYLES.colors.secondary
        })
      ],
      alignment: AlignmentType.CENTER,
      spacing: {
        after: convertInchesToTwip(3)
      }
    }),
    new Paragraph({
      children: [
        new TextRun({
          text: "Generated by ScholarlyAI",
          font: STYLES.fonts.body,
          size: 20,
          color: STYLES.colors.secondary,
          italics: true
        })
      ],
      alignment: AlignmentType.CENTER
    }),
    new Paragraph({
      children: [new PageBreak()]
    })
  ];
};

const createTableOfContents = (entries) => {
  const tocParagraphs = [
    new Paragraph({
      children: [
        new TextRun({
          text: "TABLE OF CONTENTS",
          font: STYLES.fonts.heading,
          size: 36,
          color: STYLES.colors.primary,
          bold: true
        })
      ],
      alignment: AlignmentType.CENTER,
      spacing: {
        after: convertInchesToTwip(0.5)
      }
    })
  ];
  
  entries.forEach((entry, index) => {
    const citation = cleanMarkdownContent(entry.citation);
    const truncatedCitation = citation.length > 80 ? 
      citation.substring(0, 77) + '...' : 
      citation;
    
    tocParagraphs.push(
      new Paragraph({
        children: [
          new TextRun({
            text: `Entry ${index + 1}: `,
            font: STYLES.fonts.body,
            size: 24,
            bold: true
          }),
          new TextRun({
            text: truncatedCitation,
            font: STYLES.fonts.body,
            size: 24
          })
        ],
        spacing: {
          after: 180
        },
        indent: {
          left: convertInchesToTwip(0.25)
        }
      })
    );
  });
  
  tocParagraphs.push(
    new Paragraph({
      children: [new PageBreak()]
    })
  );
  
  return tocParagraphs;
};

const createEntrySection = (entry, index) => {
  const paragraphs = [];
  
  paragraphs.push(
    new Paragraph({
      children: [
        new TextRun({
          text: `ENTRY ${index + 1}`,
          font: STYLES.fonts.heading,
          size: 32,
          color: STYLES.colors.primary,
          bold: true
        })
      ],
      heading: HeadingLevel.HEADING_1,
      spacing: {
        before: index === 0 ? 0 : STYLES.spacing.beforeHeading,
        after: STYLES.spacing.afterHeading
      },
      border: {
        bottom: {
          color: STYLES.colors.accent,
          space: 1,
          size: 12,
          style: BorderStyle.SINGLE
        }
      }
    })
  );
  
  const cleanedCitation = cleanMarkdownContent(entry.citation);
  paragraphs.push(
    createStyledParagraph(cleanedCitation, {
      font: STYLES.fonts.body,
      size: 24,
      bold: true,
      spacingAfter: 360
    })
  );
  
  if (entry.narrative_overview) {
    paragraphs.push(
      new Paragraph({
        children: [
          new TextRun({
            text: "Narrative Overview",
            font: STYLES.fonts.heading,
            size: 28,
            color: STYLES.colors.primary,
            bold: true
          })
        ],
        heading: HeadingLevel.HEADING_2,
        spacing: {
          before: STYLES.spacing.beforeHeading,
          after: STYLES.spacing.afterHeading
        }
      })
    );
    
    const cleanedOverview = cleanMarkdownContent(entry.narrative_overview);
    const overviewElements = parseMarkdownToDocxElements(cleanedOverview);
    
    overviewElements.forEach(element => {
      if (element.type === 'paragraph') {
        paragraphs.push(
          createStyledParagraph(element.content, {
            size: 24,
            spacingAfter: 240
          })
        );
      } else if (element.type === 'list') {
        element.items.forEach(item => {
          paragraphs.push(
            createStyledParagraph(`• ${item}`, {
              size: 24,
              spacingAfter: 120,
              indent: { left: convertInchesToTwip(0.25) }
            })
          );
        });
      }
    });
  }
  
  if (entry.research_components) {
    paragraphs.push(
      new Paragraph({
        children: [
          new TextRun({
            text: "Key Research Components",
            font: STYLES.fonts.heading,
            size: 28,
            color: STYLES.colors.primary,
            bold: true
          })
        ],
        heading: HeadingLevel.HEADING_2,
        spacing: {
          before: STYLES.spacing.beforeHeading,
          after: STYLES.spacing.afterHeading
        }
      })
    );
    
    const components = [
      { key: 'research_purpose', label: 'Research Purpose' },
      { key: 'methodology', label: 'Methodology' },
      { key: 'theoretical_framework', label: 'Theoretical Framework' }
    ];
    
    components.forEach(({ key, label }) => {
      if (entry.research_components[key]) {
        paragraphs.push(
          createStyledParagraph(label + ':', {
            size: 24,
            bold: true,
            color: STYLES.colors.secondary,
            spacingAfter: 120
          })
        );
        
        const cleanedText = cleanMarkdownContent(entry.research_components[key]);
        paragraphs.push(
          createStyledParagraph(cleanedText, {
            size: 24,
            spacingAfter: 300,
            indent: { left: convertInchesToTwip(0.25) }
          })
        );
      }
    });
  }
  
  if (entry.core_findings) {
    paragraphs.push(
      new Paragraph({
        children: [
          new TextRun({
            text: "Core Findings & Key Statistics",
            font: STYLES.fonts.heading,
            size: 28,
            color: STYLES.colors.primary,
            bold: true
          })
        ],
        heading: HeadingLevel.HEADING_2,
        spacing: {
          before: STYLES.spacing.beforeHeading,
          after: STYLES.spacing.afterHeading
        }
      })
    );
    
    const cleanedFindings = cleanMarkdownContent(entry.core_findings);
    const findingsElements = parseMarkdownToDocxElements(cleanedFindings);
    
    findingsElements.forEach(element => {
      if (element.type === 'paragraph') {
        paragraphs.push(
          createStyledParagraph(element.content, {
            size: 24,
            spacingAfter: 240
          })
        );
      } else if (element.type === 'list') {
        element.items.forEach(item => {
          paragraphs.push(
            createStyledParagraph(`• ${item}`, {
              size: 24,
              spacingAfter: 120,
              indent: { left: convertInchesToTwip(0.25) }
            })
          );
        });
      }
    });
  }
  
  if (entry.methodological_value) {
    paragraphs.push(
      new Paragraph({
        children: [
          new TextRun({
            text: "Methodological Value",
            font: STYLES.fonts.heading,
            size: 28,
            color: STYLES.colors.primary,
            bold: true
          })
        ],
        heading: HeadingLevel.HEADING_2,
        spacing: {
          before: STYLES.spacing.beforeHeading,
          after: STYLES.spacing.afterHeading
        }
      })
    );
    
    if (entry.methodological_value.strengths) {
      paragraphs.push(
        createStyledParagraph('Strengths:', {
          size: 24,
          bold: true,
          color: STYLES.colors.secondary,
          spacingAfter: 120
        })
      );
      
      const cleanedStrengths = cleanMarkdownContent(entry.methodological_value.strengths);
      paragraphs.push(
        createStyledParagraph(cleanedStrengths, {
          size: 24,
          spacingAfter: 300,
          indent: { left: convertInchesToTwip(0.25) }
        })
      );
    }
    
    if (entry.methodological_value.limitations) {
      paragraphs.push(
        createStyledParagraph('Limitations:', {
          size: 24,
          bold: true,
          color: STYLES.colors.secondary,
          spacingAfter: 120
        })
      );
      
      const cleanedLimitations = cleanMarkdownContent(entry.methodological_value.limitations);
      paragraphs.push(
        createStyledParagraph(cleanedLimitations, {
          size: 24,
          spacingAfter: 300,
          indent: { left: convertInchesToTwip(0.25) }
        })
      );
    }
  }
  
  if (entry.key_quotes && entry.key_quotes.length > 0) {
    paragraphs.push(
      new Paragraph({
        children: [
          new TextRun({
            text: "Key Quotes",
            font: STYLES.fonts.heading,
            size: 28,
            color: STYLES.colors.primary,
            bold: true
          })
        ],
        heading: HeadingLevel.HEADING_2,
        spacing: {
          before: STYLES.spacing.beforeHeading,
          after: STYLES.spacing.afterHeading
        }
      })
    );
    
    entry.key_quotes.forEach((quote, qIndex) => {
      paragraphs.push(
        createStyledParagraph(
          `${qIndex + 1}. "${cleanMarkdownContent(quote.text)}" (p. ${quote.page})`,
          {
            size: 24,
            italics: true,
            spacingAfter: 180,
            indent: { left: convertInchesToTwip(0.25) }
          }
        )
      );
    });
  }
  
  if (index < entry.totalEntries - 1) {
    paragraphs.push(
      new Paragraph({
        children: [new PageBreak()]
      })
    );
  }
  
  return paragraphs;
};

export const exportToWord = async (entries, options = {}) => {
  const {
    includeTableOfContents = true,
    includeTitlePage = true,
    includeHeaders = true,
    includeFooters = true
  } = options;
  
  const sections = [];
  const children = [];
  
  if (includeTitlePage) {
    children.push(...createTitlePage(entries));
  }
  
  if (includeTableOfContents && entries.length > 1) {
    children.push(...createTableOfContents(entries));
  }
  
  entries.forEach((entry, index) => {
    const entryWithTotal = { ...entry, totalEntries: entries.length };
    children.push(...createEntrySection(entryWithTotal, index));
  });
  
  sections.push({
    properties: {
      page: {
        margin: {
          top: convertInchesToTwip(1),
          right: convertInchesToTwip(1),
          bottom: convertInchesToTwip(1),
          left: convertInchesToTwip(1),
        }
      }
    },
    headers: includeHeaders ? {
      default: createDocumentHeader()
    } : undefined,
    footers: includeFooters ? {
      default: createDocumentFooter()
    } : undefined,
    children: children
  });
  
  const doc = new Document({
    sections: sections,
    numbering: {
      config: [
        {
          reference: "default-bullet-numbering",
          levels: [
            {
              level: 0,
              format: NumberFormat.BULLET,
              text: "•",
              alignment: AlignmentType.LEFT,
              style: {
                paragraph: {
                  indent: { left: convertInchesToTwip(0.5), hanging: convertInchesToTwip(0.25) }
                }
              }
            }
          ]
        }
      ]
    },
    styles: {
      default: {
        heading1: {
          run: {
            font: STYLES.fonts.heading,
            size: 32,
            bold: true,
            color: STYLES.colors.primary
          },
          paragraph: {
            spacing: {
              before: STYLES.spacing.beforeHeading,
              after: STYLES.spacing.afterHeading
            }
          }
        },
        heading2: {
          run: {
            font: STYLES.fonts.heading,
            size: 28,
            bold: true,
            color: STYLES.colors.primary
          },
          paragraph: {
            spacing: {
              before: STYLES.spacing.beforeHeading,
              after: STYLES.spacing.afterHeading
            }
          }
        }
      }
    }
  });
  
  const blob = await Packer.toBlob(doc);
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `annotated-bibliography-${Date.now()}.docx`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  
  return true;
};